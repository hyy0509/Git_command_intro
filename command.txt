git remote: 查看远程仓库
git remote -v: 查看远程仓库的详细信息
git status: 仓库当前的状态
git diff: 修改了文件，但没有上传，查看修改的内容
git log: 查看修改历史(修改的历史记录)
git log --pretty=oneline: 查看修改历史，返回: commit id + "提交说明"
git log --pretty=oneline --abbrev-commit: 查看修改历史，返回: commit id (缩写) + "提交说明"
git reflog: 查看命令历史（返回每一次命令的内容）
git diff HEAD --readme.txt:查看工作区和版本库里最新版本的区别
git branch: 查看当前分支
git push origin master: 推送master到远程库
git push origin dev: 推送分支dev到远程库
git add .: 添加所有文件


将远程库的项目克隆到本地:
git clone url			------这里URL为远程库地址，clone到本地的文件包含了远程库的所有分支
git branch -r			------查看远程库分支
git branch -a			------查看所有分支


若想clone远程库的某个分支:
step 1: git clone url				------clone远程库的master分支到本地
step 2: git branch -r				------查看远程库分支
返回形式如下:
origin/HEAD -> origin/master
origin/annual_planner_kaihua
origin/annual_planner_local
origin/huangyan
origin/master
step 3: git checkout origin/huangyan		------(将远程库中的分支huangyan克隆到本地)



把一个文件(例如: readme.txt)添加到Git仓库:
step 1: git add readme.txt		------(把要提交的所有修改放到暂存区)         
step 2: git commit -m "提交说明"	------(把暂存区的所有修改提交到分支)


回退:
HEAD: 当前版本
HEAD^: 上一个版本
HEAD^^: 上上一个版本
HEAD~100: 往上第100个版本
cat readme.txt: 查看文件readme.txt
git reset --hard HEAD^: 回退到上一个版本
git reset --hard commit id: 回退到commit id 对应的版本


管理修改:
Remark: Git跟踪管理的是修改，而不是文件。
例 1: 若操作过程为:
step 1: 第一次修改
step 2: git add
step 3: 第二次修改
step 4: git commit
这里，git add 将第一次修改放到了暂存区，因此git commit 提交的是第一次修改，而非第二次。
例 2: 若操作过程为:
step 1: 第一次修改
step 2: git add
step 3: 第二次修改
step 4: git add
step 5: git commit
这里则将两次修改合并提交。


撤销修改：
git checkout -- readme.txt: 把readme.txt文件在工作区的修改全部撤销。此时有两种情况:
情况 1: readme.txt 自修改后还没有放到暂存区，则撤销修改回到了和版本库一模一样的状态；
情况 2: readme.txt 已经添加得到暂存区后，又做了修改，则撤销回到添加到暂存区后的状态。
总之，文件回到最近一次git commit或git add时的状态。
git reset HEAD readme.txt: 撤销掉暂存区的修改，重新放回到工作区


删除文件: 
rm test.txt
step 1: git rm test.txt
step 2: git commit -m "remove test.txt"


首次往远程库传文件:
step 1: git remote add origin url
step 2: git push -u origin master


Git 问题:
No.1: Reposity not found
解决方案: git remote set-url origin url
(origin 表示远程库)


创建分支:
git checkout -b dev: 创建并切换到分支dev,
其中"-b"表示创建并切换，即上一条命令相当于下面两条命令： 
git branch dev: 创建分支dev
git checkout dev: 切换到分支dev


合并分支(fast forward 模式):
在dev分支上进行修改，然后合并到master分支:
step 1: git checkout dev	------(切换到dev分支)
step 2: git add readme.txt	------(在dev分支上进行修改)
step 3: git commit -m "branch test"
step 4: git checkout master	------(切换到master分支)
step 5: git merge dev		------(将dev分支合并到master分支上)


合并分支(普通合并):
step 1: git checkout -b dev
step 2: git add readme.txt
step 3: git checkout master
step 4: git merge --no-ff -m "merge with no-ff" dev



删除分支:
git branch -d dev: 删除分支dev


管理分支的基本原则:
No.1: master 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活;
No.2: 干活都在dev分支上，也就是说，dev分支是不稳定的。到某个时候，比如1.0版本发布时，
再把dev分支合并到master上， 发布1.0版本;
No.3: 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。


bug分支:
有了bug就需要修复，在git中，由于分支是如此强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。
stash功能: 把当前工作现场"储藏起来"，等以后恢复现场时继续工作。
git stash: 把当前工作现场"储藏起来"
恢复工作现场(恢复stash):
git stash apply: 恢复后不删除stash，用命令git stash drop删除stash
git stash pop: 恢复的同时删除stash内容
若dev分支上的工作进行了一半，还不想提交，这时接到一个修复一个代号为101的bug任务时，则修复bug的过程如下:
step 1: git stash						------(把当前工作现场"储藏起来")
step 2: git checkout master					------(切换到master分支)
step 3: git checkout -b issue-101				------(创建并切换到issue-101分支)
step 4: git add readme.txt					------(添加修改后的文件)
step 5: git commit -m "fix bug 101"				------(提交bug101的修改)
step 6: git checkout master					------(切换到master分支)
step 7: git merge --no-ff -m "merged bug fix 101" issue-101	------(普通模式合并)
step 8: git checkout dev					------(切换到dev分支)
step 9: git status						------(查看仓库当前的状态，由于之前git stash了，这时工作区是干净的)
step 10: git stash list						------(查看stash内容)
step 11: git stash pop 						------(恢复stash内容)
step 12: git stash list 					------(查看stash内容，由于已经恢复并删除了stash内容，这时看不到任何stash内容了)

Remark: 可以多次stash，恢复的时候，先用git stash list 查看，然后恢复指定的stash，用命令: git stash apply stash@{0}


标签管理:
作用: 版本库中打标签，确定了打标签时刻的版本。

创建标签:
git tag v1.0: 打新标签v1.0
git tag: 查看所有标签

通过commit id打标签:
step 1: git log --pretty=oneline --abbrev-commit
step 2: git tag v0.9 commit id

Remark: 标签不按时间顺序，而是按照字母顺序

创建带有说明的标签:
git tag -a v0.1 -m "version 0.1 is released" commit id: 其中"-a"指定标签名，"-m"指定说明文字

git show v0.9: 查看版本v0.9
git tag -d v0.1: 删除标签v0.1
git push origin v1.0: 推送标签v0.1到远程库
git push origin --tags: 一次性推送全部未推送的标签

删除远程库的标签:
step 1: git tag -d v0.9 			------(先删除本地)
step 2: git push origin :refs/tags/v0.9  	------(删除远程库)


使用Github:					------(Fork项目到自己的Github中)
step 1: Fork
step 2: clone 					------(从自己的账号下clone，这样才能传送修改)

Remark: 若希望他人接受你的修改，则需发起pull request。

